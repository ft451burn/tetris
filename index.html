<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        #game-container {
            background-color: #111;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        canvas {
            border: 2px solid #444;
            background-color: #000;
        }
        
        #score {
            color: white;
            font-size: 20px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        #controls {
            color: white;
            margin-top: 10px;
            text-align: center;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score">Score: 0</div>
        <canvas id="tetris" width="300" height="600"></canvas>
        <div id="controls">
            ← → : Move | ↓ : Soft Drop | ↑ : Rotate | Space : Hard Drop
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        
        const ROWS = 20;
        const COLS = 10;
        const BLOCK_SIZE = 30;
        
        // Tetromino shapes
        const SHAPES = {
            I: {
                shape: [
                    [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
                    [[0,0,1,0], [0,0,1,0], [0,0,1,0], [0,0,1,0]],
                    [[0,0,0,0], [0,0,0,0], [1,1,1,1], [0,0,0,0]],
                    [[0,1,0,0], [0,1,0,0], [0,1,0,0], [0,1,0,0]]
                ],
                color: '#00f0f0'
            },
            O: {
                shape: [
                    [[1,1], [1,1]]
                ],
                color: '#f0f000'
            },
            T: {
                shape: [
                    [[0,1,0], [1,1,1], [0,0,0]],
                    [[0,1,0], [0,1,1], [0,1,0]],
                    [[0,0,0], [1,1,1], [0,1,0]],
                    [[0,1,0], [1,1,0], [0,1,0]]
                ],
                color: '#a000f0'
            },
            S: {
                shape: [
                    [[0,1,1], [1,1,0], [0,0,0]],
                    [[0,1,0], [0,1,1], [0,0,1]],
                    [[0,0,0], [0,1,1], [1,1,0]],
                    [[1,0,0], [1,1,0], [0,1,0]]
                ],
                color: '#00f000'
            },
            Z: {
                shape: [
                    [[1,1,0], [0,1,1], [0,0,0]],
                    [[0,0,1], [0,1,1], [0,1,0]],
                    [[0,0,0], [1,1,0], [0,1,1]],
                    [[0,1,0], [1,1,0], [1,0,0]]
                ],
                color: '#f00000'
            },
            J: {
                shape: [
                    [[1,0,0], [1,1,1], [0,0,0]],
                    [[0,1,1], [0,1,0], [0,1,0]],
                    [[0,0,0], [1,1,1], [0,0,1]],
                    [[0,1,0], [0,1,0], [1,1,0]]
                ],
                color: '#0000f0'
            },
            L: {
                shape: [
                    [[0,0,1], [1,1,1], [0,0,0]],
                    [[0,1,0], [0,1,0], [0,1,1]],
                    [[0,0,0], [1,1,1], [1,0,0]],
                    [[1,1,0], [0,1,0], [0,1,0]]
                ],
                color: '#f0a000'
            }
        };
        
        // Game state
        let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        let currentPiece = null;
        let currentX = 0;
        let currentY = 0;
        let currentRotation = 0;
        let score = 0;
        let dropTimer = 0;
        let dropInterval = 1000; // 1 second
        
        // Create a new piece
        function createPiece() {
            const pieces = Object.keys(SHAPES);
            const randomPiece = pieces[Math.floor(Math.random() * pieces.length)];
            const piece = SHAPES[randomPiece];
            
            currentPiece = piece;
            currentRotation = 0;
            currentX = Math.floor(COLS / 2) - Math.floor(piece.shape[0][0].length / 2);
            currentY = 0;
            
            // Check if game over
            if (!isValidPosition(currentX, currentY, currentRotation)) {
                gameOver();
            }
        }
        
        // Check if position is valid (no collision)
        function isValidPosition(x, y, rotation) {
            const shape = currentPiece.shape[rotation % currentPiece.shape.length];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const newX = x + col;
                        const newY = y + row;
                        
                        // Check boundaries
                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return false;
                        }
                        
                        // Check collision with placed pieces (only if within board)
                        if (newY >= 0 && board[newY][newX]) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }
        
        // Place piece on board
        function placePiece() {
            const shape = currentPiece.shape[currentRotation % currentPiece.shape.length];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardY = currentY + row;
                        const boardX = currentX + col;
                        
                        if (boardY >= 0) {
                            board[boardY][boardX] = currentPiece.color;
                        }
                    }
                }
            }
            
            // Check for completed lines
            clearLines();
            
            // Create new piece
            createPiece();
        }
        
        // Clear completed lines
        function clearLines() {
            let linesCleared = 0;
            
            for (let row = ROWS - 1; row >= 0; row--) {
                if (board[row].every(cell => cell !== 0)) {
                    board.splice(row, 1);
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    row++; // Check the same row again
                }
            }
            
            if (linesCleared > 0) {
                score += linesCleared * 100;
                updateScore();
            }
        }
        
        // Draw the game
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw board
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col]) {
                        ctx.fillStyle = board[row][col];
                        ctx.fillRect(col * BLOCK_SIZE, row * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                    }
                }
            }
            
            // Draw current piece
            if (currentPiece) {
                const shape = currentPiece.shape[currentRotation % currentPiece.shape.length];
                ctx.fillStyle = currentPiece.color;
                
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (shape[row][col]) {
                            ctx.fillRect(
                                (currentX + col) * BLOCK_SIZE,
                                (currentY + row) * BLOCK_SIZE,
                                BLOCK_SIZE - 1,
                                BLOCK_SIZE - 1
                            );
                        }
                    }
                }
            }
            
            // Draw grid lines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * BLOCK_SIZE, 0);
                ctx.lineTo(i * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                ctx.stroke();
            }
            
            for (let i = 0; i <= ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * BLOCK_SIZE);
                ctx.lineTo(COLS * BLOCK_SIZE, i * BLOCK_SIZE);
                ctx.stroke();
            }
        }
        
        // Move piece
        function movePiece(dx, dy) {
            const newX = currentX + dx;
            const newY = currentY + dy;
            
            if (isValidPosition(newX, newY, currentRotation)) {
                currentX = newX;
                currentY = newY;
                return true;
            }
            
            return false;
        }
        
        // Rotate piece
        function rotatePiece() {
            const newRotation = (currentRotation + 1) % currentPiece.shape.length;
            
            if (isValidPosition(currentX, currentY, newRotation)) {
                currentRotation = newRotation;
                return true;
            }
            
            // Try wall kicks
            const kicks = [
                [0, 0],
                [-1, 0], [1, 0],  // left, right
                [0, -1],          // up
                [-1, -1], [1, -1] // up-left, up-right
            ];
            
            for (const [dx, dy] of kicks) {
                if (isValidPosition(currentX + dx, currentY + dy, newRotation)) {
                    currentX += dx;
                    currentY += dy;
                    currentRotation = newRotation;
                    return true;
                }
            }
            
            return false;
        }
        
        // Drop piece
        function dropPiece() {
            if (!movePiece(0, 1)) {
                placePiece();
            }
        }
        
        // Hard drop
        function hardDrop() {
            while (movePiece(0, 1)) {
                // Keep moving down
            }
            placePiece();
        }
        
        // Update score display
        function updateScore() {
            document.getElementById('score').textContent = 'Score: ' + score;
        }
        
        // Game over
        function gameOver() {
            alert('Game Over! Score: ' + score);
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            score = 0;
            updateScore();
            createPiece();
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!currentPiece) return;
            
            switch(e.key) {
                case 'ArrowLeft':
                    movePiece(-1, 0);
                    break;
                case 'ArrowRight':
                    movePiece(1, 0);
                    break;
                case 'ArrowDown':
                    dropPiece();
                    break;
                case 'ArrowUp':
                    rotatePiece();
                    break;
                case ' ':
                    hardDrop();
                    break;
            }
            
            draw();
        });
        
        // Game loop
        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            dropTimer += deltaTime;
            
            if (dropTimer >= dropInterval) {
                dropPiece();
                dropTimer = 0;
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Start game
        createPiece();
        updateScore();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>